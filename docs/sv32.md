# SV32 Paging (2-Level)

対象:

- `src/include/memory.h`
- `src/kernel/mm/memory.c`
- `src/kernel/proc/process.c`

関連:

- [Memory / Process](./memory-process.md)
- [Mode Transition](./mode-transition.md)

## 1. SV32 概要

RISC-V 32bitのSV32は2段ページテーブルです。

- ページサイズ: 4KB
- 仮想アドレス分解:
  - `VPN[1] = VA[31:22]`
  - `VPN[0] = VA[21:12]`
  - `offset = VA[11:0]`
- 1 テーブルは 4KB / 4byte = 1024 エントリ

PTE(32bit) の利用ビット:

- `PPN = PTE[31:10]`
- `V/R/W/X/U = PTE[0..4]`

本実装のフラグ定義は `src/include/memory.h` の `PAGE_V/R/W/X/U` を使用します。

## 2. 計算方法

本実装の `map_page()` (`src/kernel/mm/memory.c`) は以下の式です。

```c
uint32_t vpn1 = (vaddr >> 22) & 0x3ff;
uint32_t vpn0 = (vaddr >> 12) & 0x3ff;

// next level table paddr
uint32_t *table0 = (uint32_t *) ((table1[vpn1] >> 10) * PAGE_SIZE);

// leaf pte
table0[vpn0] = ((paddr / PAGE_SIZE) << 10) | flags | PAGE_V;
```

逆引き (VA -> PA) は次の式です。

1. `vpn1 = (va >> 22) & 0x3ff`
2. `vpn0 = (va >> 12) & 0x3ff`
3. `pte1 = pt1[vpn1]`
4. `pt0_base = (pte1 >> 10) << 12`
5. `pte0 = ((uint32_t*)pt0_base)[vpn0]`
6. `pa = ((pte0 >> 10) << 12) | (va & 0xfff)`

## 3. satp 設定

コンテキストスイッチ時 (`src/kernel/proc/process.c`) に `satp` を更新します。

```c
csrw satp, SATP_SV32 | ((uint32_t) next->page_table / PAGE_SIZE)
```

- `SATP_SV32` は bit31 を 1 にするモードビット
- ルートページテーブルの PPN は `page_table / 4096`

## 4. カーネル/ユーザのマッピング

`create_process()` (`src/kernel/proc/process.c`) では次を構築します。

### 4.1 カーネル領域

```c
for (paddr_t paddr = (paddr_t)__kernel_base;
     paddr < (paddr_t)__free_ram_end;
     paddr += PAGE_SIZE) {
    map_page(page_table, paddr, paddr, PAGE_R | PAGE_W | PAGE_X);
}
```

- 恒等マップ (`VA == PA`)
- `PAGE_U` は付けない

### 4.2 ユーザ領域

```c
map_page(page_table, USER_BASE + off, page,
         PAGE_U | PAGE_R | PAGE_W | PAGE_X);
```

- `USER_BASE` 以降にアプリを配置
- 実体物理ページは allocator (`alloc_pages`) から確保
- `PAGE_U` 付きでユーザアクセス許可

## 5. QEMU デバッグで VA/PA を確認する

## 5.1 gdb で手動ページウォーク

1. QEMU を gdb 待機で起動

```bash
qemu-system-riscv32 \
  -machine virt -bios default -nographic -serial mon:stdio --no-reboot \
  -S -s -kernel ./bin/kernel.elf
```

2. 別ターミナルで gdb 接続

```bash
riscv32-unknown-elf-gdb ./bin/kernel.elf
(gdb) target remote :1234
```

3. `satp` から root table を計算

```gdb
(gdb) p/x $satp
(gdb) set $pt1 = ($satp & 0x003fffff) << 12
```

4. 例: `va=0x01000000` を変換

```gdb
(gdb) set $va = 0x01000000
(gdb) set $vpn1 = ($va >> 22) & 0x3ff
(gdb) set $vpn0 = ($va >> 12) & 0x3ff
(gdb) x/wx $pt1 + 4*$vpn1
(gdb) set $pte1 = *(unsigned int*)($pt1 + 4*$vpn1)
(gdb) set $pt0 = (($pte1 >> 10) << 12)
(gdb) x/wx $pt0 + 4*$vpn0
(gdb) set $pte0 = *(unsigned int*)($pt0 + 4*$vpn0)
(gdb) p/x ((($pte0 >> 10) << 12) | ($va & 0xfff))
```

これで `VA -> PA` を実測できます。

## 5.2 QEMU の MMU ログを使う

QEMU の MMU ログを有効化すると、変換ログに VA/PA が出ます。

```bash
qemu-system-riscv32 \
  -machine virt -bios default -nographic -serial mon:stdio --no-reboot \
  -d mmu,guest_errors -D qemu.log \
  -kernel ./bin/kernel.elf
```

`qemu.log` を確認して、対象命令時の変換を追います。
